<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Route Finder</title>
    
    <!-- PWA (Progressive Web App) related meta tags for app-like behavior -->
    <!-- For iOS: Enables full-screen app mode -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <!-- For iOS: Sets the status bar style -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- For Android: Enables full-screen app mode -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- PWA Manifest file -->
    <link rel="manifest" href="manifest.json">
    <!-- Icon for iOS Home Screen -->
    <link rel="apple-touch-icon" href="https://placehold.co/192x192/000000/FFFFFF?text=RF">

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f5f5f5;
            color: #1a1a1a;
            position: relative;
        }
        #map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 0;
        }
        #controlsCard {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 600px;
            background-color: white;
            border-radius: 2rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            padding: 1rem;
            z-index: 10;
        }
        @media (min-width: 768px) {
            #controlsCard {
                padding: 2.5rem;
            }
        }
        /* Custom styles for Material 3-like sliders */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            outline: none;
            transition: background 0.2s ease-in-out;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            height: 4px;
            background: #e0e0e0; /* Fixed: default background is now a single color */
            border-radius: 2px;
        }
        input[type="range"]::-moz-range-track {
            height: 4px;
            background: #e0e0e0; /* Fixed: default background is now a single color */
            border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 20px;
            width: 20px;
            background-color: #2196f3;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            margin-top: -8px;
            transition: box-shadow 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        input[type="range"]:active::-webkit-slider-thumb {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transform: scale(1.1);
        }
        input[type="range"]::-moz-range-thumb {
            height: 20px;
            width: 20px;
            background-color: #2196f3;
            border: none;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: box-shadow 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        input[type="range"]:active::-moz-range-thumb {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transform: scale(1.1);
        }

        #routeListContainer {
            z-index: 10;
            padding-top: 1rem;
            width: 100%;
        }
        #routeList {
            display: flex;
            gap: 1.5rem;
            overflow-x: scroll;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 1rem; /* Space for scrollbar */
            padding-top: 0.5rem;
        }
        #routeList::-webkit-scrollbar {
            display: none;
        }
        .route-item {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, border 0.2s;
            flex-shrink: 0;
            width: 80vw;
            max-width: 400px;
            scroll-snap-align: center;
        }
        .route-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .route-item.active {
            border: 2px solid #2196f3;
            box-shadow: 0 0 10px rgba(33, 150, 243, 0.5);
        }
    </style>
</head>
<body>
    <!-- Map container now fills the entire screen -->
    <div id="map"></div>

    <!-- Floating controls card -->
    <div id="controlsCard" class="flex flex-col items-center space-y-4">

        <div class="w-full flex flex-col space-y-3">
            <!-- Location search and selection section (now with icons) -->
            <div class="bg-gray-50 p-3 rounded-2xl shadow-inner flex flex-row space-x-2 w-full items-center">
                <input type="text" id="locationInput" placeholder="Enter a location..." class="flex-grow rounded-xl shadow-sm border-gray-300 focus:border-[#2196f3] focus:ring-[#2196f3] p-2 text-sm">
                <button id="searchLocationBtn" class="p-2 bg-[#2196f3] text-white rounded-xl shadow-md hover:bg-[#1976d2] transition-colors font-bold flex-shrink-0" aria-label="Search location">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" class="w-5 h-5">
                         <path d="M21 21L16.65 16.65M19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
               
            </div>

            <!-- Route controls section (more compact) -->
            <div class="bg-[#f5f5f5] p-3 rounded-2xl flex flex-col space-y-3">
                <div class="flex items-center justify-around space-x-2 w-full">
				 <button id="useCurrentLocationBtn" class="p-2 bg-gray-500 text-white rounded-xl shadow-md hover:bg-gray-600 transition-colors flex-shrink-0 flex-1" aria-label="Use current location">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" class="w-5 h-5 mx-auto">
                         <path d="M22 12H18M6 12H2M12 6V2M12 22V18M20 12C20 16.4183 16.4183 20 12 20C7.58172 20 4 16.4183 4 12C4 7.58172 7.58172 4 12 4C16.4183 4 20 7.58172 20 12ZM15 12C15 13.6569 13.6569 15 12 15C10.3431 15 9 13.6569 9 12C9 10.3431 10.3431 9 12 9C13.6569 9 15 10.3431 15 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <button id="pickOnMapBtn" class="p-2 bg-gray-500 text-white rounded-xl shadow-md hover:bg-gray-600 transition-colors flex-shrink-0 flex-1" aria-label="Pick location on map">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" class="w-5 h-5 mx-auto">
                         <path d="M5 14.2864C3.14864 15.1031 2 16.2412 2 17.5C2 19.9853 6.47715 22 12 22C17.5228 22 22 19.9853 22 17.5C22 16.2412 20.8514 15.1031 19 14.2864M18 8C18 12.0637 13.5 14 12 17C10.5 14 6 12.0637 6 8C6 4.68629 8.68629 2 12 2C15.3137 2 18 4.68629 18 8ZM13 8C13 8.55228 12.5523 9 12 9C11.4477 9 11 8.55228 11 8C11 7.44772 11.4477 7 12 7C12.5523 7 13 7.44772 13 8Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                    <!-- Length Filter -->
                    <button id="toggleLengthBtn" class="w-full px-4 py-2 bg-gray-500 text-white rounded-xl shadow-md hover:bg-gray-600 transition-colors font-bold text-sm flex items-center justify-center space-x-2 flex-1">
                         <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" class="w-5 h-5">
                            <path d="M14.5 5.49989L16 6.99989M11.5 8.49989L13 9.99989M8.49996 11.4999L9.99996 12.9999M5.49996 14.4999L6.99996 15.9999M2.56561 17.5656L6.43424 21.4342C6.63225 21.6322 6.73125 21.7313 6.84542 21.7683C6.94584 21.801 7.05401 21.801 7.15443 21.7683C7.2686 21.7313 7.3676 21.6322 7.56561 21.4342L21.4342 7.56561C21.6322 7.3676 21.7313 7.2686 21.7683 7.15443C21.801 7.05401 21.801 6.94584 21.7683 6.84542C21.7313 6.73125 21.6322 6.63225 21.4342 6.43424L17.5656 2.56561C17.3676 2.3676 17.2686 2.2686 17.1544 2.2315C17.054 2.19887 16.9458 2.19887 16.8454 2.2315C16.7313 2.2686 16.6322 2.3676 16.4342 2.56561L2.56561 16.4342C2.3676 16.6322 2.2686 16.7313 2.2315 16.8454C2.19887 16.9458 2.19887 17.054 2.2315 17.1544C2.2686 17.2686 2.3676 17.3676 2.56561 17.5656Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    </button>
                    <!-- Radius Filter -->
                    <button id="toggleRadiusBtn" class="w-full px-4 py-2 bg-gray-500 text-white rounded-xl shadow-md hover:bg-gray-600 transition-colors font-bold text-sm flex items-center justify-center space-x-2 flex-1">
                           <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5">
                             <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-12c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z" />
                           </svg>
                    </button>
                    <button id="toggleNumRoutesBtn" class="w-full px-4 py-2 bg-gray-500 text-white rounded-xl shadow-md hover:bg-gray-600 transition-colors font-bold text-sm flex items-center justify-center space-x-2 flex-1">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" class="w-5 h-5">
                            <path d="M21 5L10 5M21 19L10 19M21 12L10 12M6 5C6 5.82843 5.32843 6.5 4.5 6.5C3.67157 6.5 3 5.82843 3 5C3 4.17157 3.67157 3.5 4.5 3.5C5.32843 3.5 6 4.17157 6 5ZM6 19C6 19.8284 5.32843 20.5 4.5 20.5C3.67157 20.5 3 19.8284 3 19C3 18.1716 3.67157 17.5 4.5 17.5C5.32843 17.5 6 18.1716 6 19ZM6 12C6 12.8284 5.32843 13.5 4.5 13.5C3.67157 13.5 3 12.8284 3 12C3 11.1716 3.67157 10.5 4.5 10.5C5.32843 10.5 6 11.1716 6 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                   </div>
                   

                <!-- Sliders and Inputs (initially hidden) -->
                <div id="numRoutesControls" class="hidden flex items-center space-x-2 w-full">
                       <input type="range" id="numRoutesSlider" min="1" max="10" value="5" class="flex-grow">
                       <input type="number" id="numRoutesInput" min="1" max="10" value="5" class="w-20 rounded-xl border-gray-300 focus:border-[#2196f3] focus:ring-[#2196f3] p-1 text-sm">
                </div>
                <div id="lengthControls" class="hidden flex items-center space-x-2 w-full">
                    <input type="range" id="routeLengthSlider" min="1" max="20" value="3" class="flex-grow">
                    <input type="number" id="routeLengthInput" min="1" max="20" value="3" class="w-20 rounded-xl border-gray-300 focus:border-[#2196f3] focus:ring-[#2196f3] p-1 text-sm">
                </div>
                <div id="radiusControls" class="hidden flex items-center space-x-2 w-full">
                    <input type="range" id="maxRadiusSlider" min="1" max="20" value="3" class="flex-grow">
                    <input type="number" id="maxRadiusInput" min="1" max="20" value="3" class="w-20 rounded-xl border-gray-300 focus:border-[#2196f3] focus:ring-[#2196f3] p-1 text-sm">
                </div>
				                <!-- Generate Route Button with integrated message -->
                   <button id="generateRouteBtn" class="w-full px-6 py-3 text-sm sm:text-base font-bold rounded-2xl text-white bg-[#2196f3] hover:bg-[#1976d2] focus:outline-none focus:ring-4 focus:ring-offset-2 focus:ring-[#2196f3] transition-all duration-300 shadow-lg flex items-center justify-center space-x-2">
                        <span>Generate Routes</span>
                            <svg id="loadingSpinner" class="animate-spin h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </button>
            </div>
        </div>
        
        <!-- List of routes now inside the controls card -->
        <div id="routeListContainer" class="hidden">
            <ul id="routeList">
                <!-- Route items will be dynamically added here -->
            </ul>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const mapElement = document.getElementById('map');
            const generateRouteBtn = document.getElementById('generateRouteBtn');
            const routeLengthSlider = document.getElementById('routeLengthSlider');
            const routeLengthInput = document.getElementById('routeLengthInput');
            const maxRadiusSlider = document.getElementById('maxRadiusSlider');
            const maxRadiusInput = document.getElementById('maxRadiusInput');
            const numRoutesSlider = document.getElementById('numRoutesSlider');
            const numRoutesInput = document.getElementById('numRoutesInput');
            const locationInput = document.getElementById('locationInput');
            const searchLocationBtn = document.getElementById('searchLocationBtn');
            const useCurrentLocationBtn = document.getElementById('useCurrentLocationBtn');
            const pickOnMapBtn = document.getElementById('pickOnMapBtn');
            const toggleLengthBtn = document.getElementById('toggleLengthBtn');
            const toggleRadiusBtn = document.getElementById('toggleRadiusBtn');
            const toggleNumRoutesBtn = document.getElementById('toggleNumRoutesBtn');
            const lengthControls = document.getElementById('lengthControls');
            const radiusControls = document.getElementById('radiusControls');
            const numRoutesControls = document.getElementById('numRoutesControls');
            const routeListContainer = document.getElementById('routeListContainer');
            const routeList = document.getElementById('routeList');
            const loadingSpinner = document.getElementById('loadingSpinner');

            let map;
            let userMarker;
            let routePolyline;
            let currentLocation = null;
            let pickMode = false;
            let abortController = null;
            let isGenerating = false;
            let foundRoutes = [];
            let observer;

            // Show a temporary message by updating the button text
            function showButtonMessage(text) {
                generateRouteBtn.querySelector('span').textContent = text;
            }

            // Update the slider track fill color
            function updateSliderFill(slider, input) {
                const value = (input.value - slider.min) / (slider.max - slider.min) * 100;
                slider.style.background = `linear-gradient(to right, #2196f3 ${value}%, #e0e0e0 ${value}%)`;
            }

            // Get initial location using IP, and fall back to a default if that fails.
            async function getInitialLocation() {
                showButtonMessage('Finding your location...');
                try {
                    const response = await fetch('https://ipinfo.io/json');
                    const data = await response.json();
                    if (data && data.loc) {
                        const [lat, lon] = data.loc.split(',').map(Number);
                        currentLocation = [lat, lon];
                        showButtonMessage('Location found! Generate a route.');
                        initializeMap();
                    } else {
                        throw new Error('IP location data not found.');
                    }
                } catch (error) {
                    console.error('IP location failed, using default:', error);
                    currentLocation = [51.505, -0.09]; // Default to London
                    showButtonMessage('Using default location. Tap to pick yours.');
                    initializeMap();
                }
            }

            // Get user's current precise location via GPS
            function getPreciseLocation() {
                if (!navigator.geolocation) {
                    showButtonMessage('Geolocation is not supported.');
                    return;
                }
                showButtonMessage('Getting your precise location...');
                navigator.geolocation.getCurrentPosition(position => {
                    currentLocation = [position.coords.latitude, position.coords.longitude];
                    showButtonMessage('Precise location found!');
                    initializeMap();
                }, () => {
                    showButtonMessage('Location access denied.');
                });
            }

            // Search for a location using a free geocoding service
            function searchLocation() {
                const query = locationInput.value;
                if (!query) {
                    showButtonMessage('Please enter a location.');
                    return;
                }
                showButtonMessage('Searching...');
                fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.length > 0) {
                            const lat = parseFloat(data[0].lat);
                            const lon = parseFloat(data[0].lon);
                            currentLocation = [lat, lon];
                            showButtonMessage(`Found: ${data[0].display_name.split(',')[0]}`);
                            initializeMap();
                        } else {
                            showButtonMessage('Location not found. Try another.');
                        }
                    })
                    .catch(() => {
                        showButtonMessage('Search error. Try again.');
                    });
            }

            // Enable picking a location on the map
            function enablePickMode() {
                if (!map) {
                    showButtonMessage('Map not ready. Try finding location first.');
                    return;
                }
                pickMode = true;
                mapElement.style.cursor = 'crosshair';
                showButtonMessage('Click on the map to set location.');
                
                map.on('click', onMapClick);
            }

            // Handle map click for picking a location
            function onMapClick(e) {
                if (pickMode) {
                    currentLocation = [e.latlng.lat, e.latlng.lng];
                    showButtonMessage('Location selected!');
                    initializeMap();
                    pickMode = false;
                    mapElement.style.cursor = 'grab';
                    map.off('click', onMapClick);
                }
            }

            // Initialize the map and set up event listeners
            function initializeMap() {
                if (map) {
                    map.remove();
                }
                map = L.map('map').setView(currentLocation, 13);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);

                if (userMarker) {
                    map.removeLayer(userMarker);
                }
                userMarker = L.marker(currentLocation).addTo(map)
                    .bindPopup("Your starting point.").openPopup();
                
                if (routePolyline) {
                    map.removeLayer(routePolyline);
                }
                
                map.setView(currentLocation, 13);
            }

            // Display a single route on the map
            function displayRouteOnMap(routeCoords) {
                if (routePolyline) {
                    map.removeLayer(routePolyline);
                }
                routePolyline = L.polyline(routeCoords, {color: '#2196f3', weight: 5, opacity: 0.8}).addTo(map);
                map.fitBounds(routePolyline.getBounds().pad(0.2));
            }

            // Generate a random nearby starting point
            function generateRandomStartPoint(centerCoords) {
                const R = 6371; // Earth's radius in km
                const radius = 0.05; // 50 meters
                const randomAngle = Math.random() * 2 * Math.PI;
                const randomDistance = Math.random() * radius;

                const latRad = centerCoords[0] * Math.PI / 180;
                const lonRad = centerCoords[1] * Math.PI / 180;

                const newLatRad = Math.asin(Math.sin(latRad) * Math.cos(randomDistance / R) +
                                            Math.cos(latRad) * Math.sin(randomDistance / R) * Math.cos(randomAngle));
                const newLonRad = lonRad + Math.atan2(Math.sin(randomAngle) * Math.sin(randomDistance / R) * Math.cos(latRad),
                                                      Math.cos(randomDistance / R) - Math.sin(latRad) * Math.sin(newLatRad));
                
                return [newLatRad * 180 / Math.PI, newLonRad * 180 / Math.PI];
            }


            // Generate multiple routes with a diverse set of end points
            async function generateMultipleRoutes() {
                if (isGenerating) {
                    abortController.abort();
                    return;
                }
                
                if (!currentLocation) {
                    showButtonMessage('Select a location first.');
                    return;
                }

                isGenerating = true;
                abortController = new AbortController();
                showButtonMessage('Generating...');
                loadingSpinner.classList.remove('hidden');
                generateRouteBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                generateRouteBtn.classList.remove('bg-[#2196f3]', 'hover:bg-[#1976d2]');
                
                routeList.innerHTML = '';
                routeListContainer.classList.add('hidden');
                
                const targetLength = parseFloat(routeLengthInput.value);
                const maxRadius = parseFloat(maxRadiusInput.value);
                const numRoutes = parseInt(numRoutesInput.value);
                
                const R = 6371; // Earth's radius in km
                
                foundRoutes = [];
                const maxAttempts = 100;
                const tolerance = 0.5;

                // Disconnect old observer if it exists
                if (observer) {
                    observer.disconnect();
                }

                for (let i = 0; i < maxAttempts && foundRoutes.length < numRoutes; i++) {
                    if (abortController.signal.aborted) {
                        break;
                    }
                    
                    showButtonMessage(`Generating route ${foundRoutes.length + 1}...`);

                    const randomStartPoint = generateRandomStartPoint(currentLocation);
                    const startLatRad = randomStartPoint[0] * Math.PI / 180;
                    const startLonRad = randomStartPoint[1] * Math.PI / 180;

                    const randomAngle = Math.random() * 2 * Math.PI;
                    const randomDistance = Math.random() * maxRadius;

                    const endLatRad = Math.asin(Math.sin(startLatRad) * Math.cos(randomDistance / R) +
                                                Math.cos(latRad) * Math.sin(randomDistance / R) * Math.cos(randomAngle));
                    const endLonRad = startLonRad + Math.atan2(Math.sin(randomAngle) * Math.sin(randomDistance / R) * Math.cos(latRad),
                                                      Math.cos(randomDistance / R) - Math.sin(startLatRad) * Math.sin(endLatRad));
                    
                    const endLat = endLatRad * 180 / Math.PI;
                    const endLon = endLonRad * 180 / Math.PI;

                    const osrmUrl = `https://router.project-osrm.org/route/v1/walking/${randomStartPoint[1]},${randomStartPoint[0]};${endLon},${endLat}?overview=full&geometries=geojson`;

                    try {
                        const response = await fetch(osrmUrl, { signal: abortController.signal });
                        const data = await response.json();

                        if (data.routes && data.routes.length > 0) {
                            const route = data.routes[0];
                            const routeLength = route.distance / 1000;

                            if (Math.abs(routeLength - targetLength) <= tolerance) {
                                const routeCoords = route.geometry.coordinates.map(coord => [coord[1], coord[0]]);
                                const endPoint = routeCoords[routeCoords.length - 1];
                                const routeName = await getRouteNameFromCoords(endPoint);

                                const newRoute = {
                                    name: routeName,
                                    start: randomStartPoint,
                                    end: endPoint,
                                    coords: routeCoords,
                                    length: routeLength.toFixed(2)
                                };

                                const isDiverse = !foundRoutes.some(r => {
                                    const lastPoint = r.coords[r.coords.length - 1];
                                    const newPoint = newRoute.coords[newRoute.coords.length - 1];
                                    const distance = Math.sqrt(Math.pow(lastPoint[0] - newPoint[0], 2) + Math.pow(lastPoint[1] - newPoint[1], 2));
                                    return distance < 0.001;
                                });

                                if (isDiverse) {
                                    foundRoutes.push(newRoute);
                                    renderRouteListItem(newRoute, foundRoutes.length - 1);
                                }
                            }
                        }
                    } catch (error) {
                        if (error.name !== 'AbortError') {
                            console.error('OSRM API error:', error);
                        }
                    }
                }

                isGenerating = false;
                showButtonMessage('Generate Routes');
                loadingSpinner.classList.add('hidden');
                generateRouteBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                generateRouteBtn.classList.add('bg-[#2196f3]', 'hover:bg-[#1976d2]');

                if (foundRoutes.length === 0) {
                    showButtonMessage('No routes found. Try different values.');
                } else {
                    routeListContainer.classList.remove('hidden');
                    setupObserver();
                    showButtonMessage('Routes generated! Select a route.');
                }
            }
            
            // Get a descriptive name for the route's endpoint
            async function getRouteNameFromCoords(coords) {
                try {
                    const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${coords[0]}&lon=${coords[1]}`);
                    const data = await response.json();
                    if (data.display_name) {
                        const namedFeature = data.address.amenity || data.address.shop || data.address.leisure || data.address.road;
                        
                        if (namedFeature) {
                             return `${namedFeature}`;
                        }
                        
                        const nameParts = data.display_name.split(',').map(part => part.trim());
                        return `${nameParts[0]}`;
                    }
                } catch (error) {
                    console.error('Error getting route name:', error);
                }
                return `Random Route`;
            }

            // Function to open the route in Google Maps
            function shareToGoogleMaps(startCoords, endCoords) {
                const mapsUrl = `https://www.google.com/maps/dir/?api=1&origin=${startCoords[0]},${startCoords[1]}&destination=${endCoords[0]},${endCoords[1]}&travelmode=walking`;
                window.open(mapsUrl, '_blank');
            }

            // Render a single route list item
            function renderRouteListItem(route, index) {
                const li = document.createElement('li');
                li.className = 'route-item p-4 bg-gray-100 rounded-2xl shadow-md hover:shadow-lg flex flex-col justify-between items-start space-y-2';
                li.dataset.routeIndex = index;
                
                const routeInfo = document.createElement('div');
                routeInfo.classList.add('flex-grow');
                routeInfo.innerHTML = `<span class="font-bold text-base block text-[#1976d2]">${route.name}</span> <span class="text-gray-700 text-sm block">${route.length} km</span>`;

                const shareBtn = document.createElement('button');
                shareBtn.textContent = 'Get Directions';
                shareBtn.classList.add('px-4', 'py-2', 'bg-[#4285f4]', 'text-white', 'rounded-xl', 'shadow-md', 'hover:bg-[#3460a1]', 'transition-colors', 'font-bold', 'text-sm', 'w-full');
                shareBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    shareToGoogleMaps(route.start, route.end);
                });

                li.appendChild(routeInfo);
                li.appendChild(shareBtn);
                routeList.appendChild(li);

                li.addEventListener('click', () => {
                    li.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                });
            }

            // Set up IntersectionObserver for scroll-snapping
            function setupObserver() {
                const options = {
                    root: routeList,
                    rootMargin: '0px',
                    threshold: 0.8
                };
                
                observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const index = entry.target.dataset.routeIndex;
                            if (index !== undefined) {
                                document.querySelectorAll('.route-item').forEach(item => item.classList.remove('active'));
                                entry.target.classList.add('active');
                                displayRouteOnMap(foundRoutes[index].coords);
                            }
                        }
                    });
                }, options);

                document.querySelectorAll('.route-item').forEach(item => {
                    observer.observe(item);
                });
            }

            // Event listeners for sliders and inputs
            function setupSlider(slider, input) {
                slider.addEventListener('input', () => {
                    input.value = slider.value;
                    updateSliderFill(slider, input);
                });
                input.addEventListener('input', () => {
                    if (input.value > parseInt(slider.max)) { input.value = parseInt(slider.max); }
                    if (input.value < parseInt(slider.min)) { input.value = parseInt(slider.min); }
                    slider.value = input.value;
                    updateSliderFill(slider, input);
                });
            }
            setupSlider(routeLengthSlider, routeLengthInput);
            setupSlider(maxRadiusSlider, maxRadiusInput);
            setupSlider(numRoutesSlider, numRoutesInput);

            // Toggle visibility of slider controls
            const controls = [lengthControls, radiusControls, numRoutesControls];
            function toggleControl(controlToShow) {
                controls.forEach(control => {
                    if (control === controlToShow) {
                        control.classList.toggle('hidden');
                    } else {
                        control.classList.add('hidden');
                    }
                });
            }
            toggleLengthBtn.addEventListener('click', () => toggleControl(lengthControls));
            toggleRadiusBtn.addEventListener('click', () => toggleControl(radiusControls));
            toggleNumRoutesBtn.addEventListener('click', () => toggleControl(numRoutesControls));

            // Initial call to get initial location
            getInitialLocation();
            
            // Initial slider fill update
            updateSliderFill(routeLengthSlider, routeLengthInput);
            updateSliderFill(maxRadiusSlider, maxRadiusInput);
            updateSliderFill(numRoutesSlider, numRoutesInput);

            // Event listeners for buttons
            searchLocationBtn.addEventListener('click', searchLocation);
            useCurrentLocationBtn.addEventListener('click', getPreciseLocation);
            pickOnMapBtn.addEventListener('click', enablePickMode);
            generateRouteBtn.addEventListener('click', generateMultipleRoutes);
        });
    </script>
</body>
</html>
